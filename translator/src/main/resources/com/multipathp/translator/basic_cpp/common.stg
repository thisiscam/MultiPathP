typeMap ::= [
    "$int$": "Int",
    "$bool$": "Bool",
    "$null$": "PAny",
    "$event$": "Int",
    "$machine$": "Ptr<PMachine>",
    "$void$": "void",
    "$seq$": {PList\<<type(t.indexedInnerType)>>},
    "$map$": {PMap\<<type(t.keyType)>, <type(t.valueType)>>},
    "$tuple$": {PTuple\<<t.innerTypes:type(); separator=", ">>},
    "$namedtuple$": {PTuple\<<t.innerTypes:type(); separator=", ">>},
    "default": key
]

typeDefaultValueMap ::= [
    "$int$": "0",
    "$bool$": "false",
    "$null$": "NULL",
    "$event$": "0",
    "$machine$": "NULL",
    "$seq$": {<type(t)>()},
    "$tuple$": {<type(t)>()},
    "$namedtuple$": {<type(t)>()},
    "$map$": {<type(t)>()},
    "default": "NULL"
]

type(t) ::= "<typeMap.(t.name)>"
typeDefaultValue(t) ::= "<typeDefaultValueMap.(t.name)>"
prefixMachineName(name) ::= "Machine<name>"
machineName(machine) ::= "<prefixMachineName(machine.name)>"
cast(t, exp) ::= "static_cast\<<type(t)>>(<exp>)"

MachineImplementationFileName(machine) ::= "<machineName(machine)>.hpp"

Render(node) ::= <<
<if(node)><(node:{t | <t.class.superclass.simpleName>})(node)><endif>
>>

LValue(node) ::= "<(node:{t | <t.class.superclass.simpleName>LValue})(node)>"

FunctionParams(params) ::= <<
<params.keys: {id | <type(params.(id))> <id>}; separator=", ">
>>

FunctionImplementation(function) ::= <<
inline <type(function.retType)> <function.name>(<FunctionParams(function.params)>) {
    <Render(function.stmtBlock)>
}
>>

StmtBlock(node) ::= <<
<node.localVarDecls.keys: {id | <type(node.localVarDecls.(id))> <id>;
}><\\>
<Render(node.stmtList)>
>>

PayloadExpression() ::= <<
<if(node.payloadExpression)>, <Render(node.payloadExpression)><endif>
>>

EventPayloadArguments() ::= <<
<Render(node.eventExpression)><PayloadExpression()>
>>

AnnounceStmt(node) ::= <<
Controller::announce(<EventPayloadArguments()>);
>>

AssertStmt(node) ::= <<
passert(<Render(node.exp)>, "<node.message>");
>>

AssignStmt(node) ::= <<
<LValue(node.target)> = <Render(node.expression)>;
>>

ConditionalStmt(node) ::= <<
if(<Render(node.condition)>) {
    <Render(node.thenBranch)>
}<if(node.elseBranch)> else {
    <Render(node.elseBranch)>
}<endif>
>>

ExpStmt(node) ::= <<
<Render(node.expression)>;<//>
<if(node.expression.canRaiseEvent)>if(retcode == RAISED_EVENT) { return<if(function.retType)> <typeDefaultValue(function.retType)><endif>; }<endif>
>>

InsertStmt(node) ::= <<
<Render(node.target)>.insert(<Render(node.expression)>);
>>

PrintStmt(node) ::= <<
print("<node.string>");
>>

RaiseStmt(node) ::= <<
raise(<EventPayloadArguments()>); retcode = RAISED_EVENT; return;
>>

RemoveStmt(node) ::= <<
<Render(node.target)>.removeAt(<Render(node.expression)>);
>>

ReturnStmt(node) ::= <<
return<if(node.expression)> <Render(node.expression)><endif>;
>>

SendStmt(node) ::= <<
send(<Render(node.targetExpression)>, <EventPayloadArguments()>);
>>

StmtListStmt(node) ::= <<
<node.stmts:Render(); separator="\n">
>>

WhileStmt(node) ::= <<
while(<Render(node.condition)>) {
    <Render(node.stmt)>
}
>>

ArithmeticExpKindMap ::= [
    "ADD": "+",
    "SUB": "-",
    "MUL": "*",
    "DIV": "/"
]
ArithmeticExp(node) ::= <<
<Render(node.left)> <ArithmeticExpKindMap.(node.kind)> <Render(node.right)>
>>

BinaryLogicExpKindMap ::= [
    "OR": "|",
    "AND": "&"
]
BinaryLogicExp(node) ::= <<
<Render(node.left)> <BinaryLogicExpKindMap.(node.kind)> <Render(node.right)>
>>

BoolLiteralExpKindMap ::= [
    "TRUE": "true",
    "FALSE": "false"
]
BoolLiteralExp(node) ::= "<BoolLiteralExpKindMap.(node.kind)>"

CallExp(node) ::= <<
<node.functionName>(<node.arguments:Render(); separator=",">)
>>

CastExp(node) ::= <<
<cast(node.castToType, Render(node.expression))>
>>

ComparisonExpKindMap ::= [
    "LT": "<",
    "LE": "<=",
    "GT": ">",
    "GE": ">=",
    "NE": "!=",
    "EQ": "=="
]
ComparisonExp(node) ::= <<
<Render(node.left)> <ComparisonExpKindMap.(node.kind)> <Render(node.right)>
>>

DefaultExp(node) ::= <<
<typeDefaultValue(node.typeForDefault)>
>>

GetAttributeExp(node) ::= <<
<Render(node.targetExpression)>.v<node.index>()
>>

GetAttributeExpLValue(node) ::= <<
<LValue(node.targetExpression)>.v<node.index>l()
>>

GetIndexExp(node) ::= <<
<Render(node.targetExpression)>
<Render(node.targetExpression)>.v<node.index>()
>>

GetIndexExpLValue(node) ::= <<
<LValue(node.targetExpression)>.v<node.index>l()
>>

GetItemExp(node) ::= <<
<Render(node.targetExpression)>.get(<Render(node.indexerExpression)>)
>>

GetItemExpLValue(node) ::= <<
<Render(node.targetExpression)>.getl(<Render(node.indexerExpression)>)
>>

GroupExp(node) ::= <<
(<Render(node.expression)>)
>>

HaltExp(node) ::= <<
EVENT_HALT
>>

IdExp(node) ::= <<
<node.name>
>>

IdExpLValue(node) ::= <<
<node.name>
>>

InExp(node) ::= <<
<Render(node.right)>.containsKey(<Render(node.left)>)
>>

IntExp(node) ::= <<
<node.value>
>>

KeysExp(node) ::= <<
<Render(node.expression)>.keys()
>>

MinusExp(node) ::= <<
-<Render(node.expression)>;
>>

NamedTupleExp(node) ::= <<
<TupleExp(node)>
>>

NewExp(node) ::= <<
create\<<prefixMachineName(node.machineIdentifier)>\>(<Render(node.payloadExpression)>)
>>

NondetExp(node) ::= <<
randomBool("<node.site>")
>>

NotExp(node) ::= <<
!<Render(node.expression)>
>>

NullExp(node) ::= <<
NULL
>>

SizeofExp(node) ::= <<
<Render(node.expression)>.size()
>>

ThisExp(node) ::= <<
this
>>

TupleExp(node) ::= <<
<type(node.expressionType)>(<node.arguments:Render(); separator=", ">)
>>

ValueExp(node) ::= <<
<Render(node.expression)>.values()
>>