typeMap ::= [
    "$int$": "int",
    "$bool$": "bool",
    "$null$": "PAny",
    "$event$": "int",
    "$machine$": "PMachine*",
    "$void$": "void",
    "$seq$": "PList\<<type(t.indexedInnerType)>\>",
    "$map$": "PMap\<<type(t.keyType)>, <type(t.valueType)>\>",
    "$tuple$": "PTuple\<<t.innerTypes:type(); separator=\", \">\>",
    "$namedtuple$": "PTuple\<<t.innerTypes:type(); separator=\", \">\>",
    "default": key
]

typeDefaultValueMap ::= [
    "$int$": "0",
    "$bool$": "false",
    "$null$": "NULL",
    "$event$": "0",
    "$machine$": "NULL",
    "$seq$": "<type(t)>()",
    "$tuple$": "<type(t)>()",
    "$namedtuple$": "<type(t)>()",
    "$map$": "<type(t)>()",
    "default": "NULL"
]

type(t) ::= "<typeMap.(t.name)>"
typeDefaultValue(t) ::= "<typeDefaultValueMap.(t.name)>"
prefixMachineName(name) ::= "Machine<name>"
machineName(machine) ::= "<prefixMachineName(machine.name)>"
cast(t, exp) ::= "static_cast\<<type(t)>>(<exp>)"

MachineImplementationFileName(machine) ::= "<machineName(machine)>.hpp"

Render(node) ::= <<
<if(node)><(node:{t | <t.class.superclass.simpleName>})(node)>
<endif>
>>

LValue(node) ::= "<(node:{t | <t.class.superclass.simpleName>LValue})(node)>"

Arg(node) ::= "<if(node)>tmp<node.reference><endif>"

ExpRef() ::= "auto&& <Arg(node)> ="

FunctionParams(params) ::= <<
<params.keys: {id | <type(params.(id))> <id>}; separator=", ">
>>

FunctionImplementation(function) ::= <<
inline <type(function.retType)> <function.name>(<FunctionParams(function.params)>) {
    <StmtBlock(function.stmtBlock)><\\>
}
>>

StmtBlock(node) ::= <<
<node.localVarDecls.keys: {id | <type(node.localVarDecls.values.(id))> <id>;}><\\>
<StmtListStmt(node.stmtList)>
>>

SendArgsHelper() ::= <<
<Arg(node.eventExpression)><if(node.payloadExpression)>, <Arg(node.payloadExpression)><endif>
>>

AnnounceStmt(node) ::= <<
<[node.eventExpression, node.payloadExpression]:Render()><\\>
Controller::announce(<SendArgsHelper()>);
>>

AssertStmt(node) ::= <<
<Render(node.exp)><\\>
assert(<Arg(node.exp)>, "<node.message>");
>>

AssignStmt(node) ::= <<
<Render(node.expression)><\\>
<LValue(node.target)> = <Arg(node.expression)>;
>>

ConditionalStmt(node) ::= <<
<Render(node.condition)><\\>
if(<Arg(node.condition)>) {
    <Render(node.thenBranch)>
}<if(node.elseBranch)> else {
    <Render(node.elseBranch)>
}<endif>
>>

ExpStmt(node) ::= "<Render(node.expression)>"

InsertStmt(node) ::= <<
<[node.target, node.expression]:Render()><\\>
<Arg(node.target)>.insert(<Arg(node.expression)>);
>>

PrintStmt(node) ::= <<
print("<node.string>");
>>

RaiseStmt(node) ::= <<
<[node.eventExpression, node.payloadExpression]:Render()><\\>
raise(<SendArgsHelper()>); retcode = RAISED_EVENT; return;
>>

RemoveStmt(node) ::= <<
<[node.target, node.expression]:Render()><\\>
<Arg(node.target)>.removeAt(<Arg(node.expression)>);
>>

ReturnStmt(node) ::= <<
<Render(node.expression)><\\>
return<if(node.expression)> <Arg(node.expression)><endif>;
>>

SendStmt(node) ::= <<
<[node.targetExpression, node.eventExpression, node.payloadExpression]:Render()><\\>
send(<Arg(node.targetExpression)>, <SendArgsHelper()>);
>>

SetAttributeStmt(node) ::= <<
<Render(node.expression)><\\>
<LValue(node.target)> = <Arg(node.expression)>;
>>

SetIndexStmt(node) ::= <<
<Render(node.expression)><\\>
<LValue(node.target)> = <Arg(node.expression)>;
>>

SetItemStmt(node) ::= <<
<Render(node.target.targetExpression)><\\>
<Render(node.target.indexerExpression)><\\>
<Render(node.expression)><\\>
<LValue(node.target.targetExpression)>.set(<Arg(node.target.indexerExpression)>, <Arg(node.expression)>);
>>

StmtListStmt(node) ::= <<
<node.stmts:Render()>
>>

WhileStmt(node) ::= <<
<Render(node.condition)><\\>
while(<Arg(node.condition)>) {
    <Render(node.stmt)><\\>
}
>>

ArithmeticExpKindMap ::= [
    "ADD": "+",
    "SUB": "-",
    "MUL": "*",
    "DIV": "/"
]
ArithmeticExp(node) ::= <<
<Render(node.left)><\\>
<Render(node.right)><\\>
<ExpRef()> <Arg(node.left)> <ArithmeticExpKindMap.(node.kind)> <Arg(node.right)>;
>>

BinaryLogicExpKindMap ::= [
    "OR": "|",
    "AND": "&"
]
BinaryLogicExp(node) ::= <<
<Render(node.left)><\\>
<Render(node.right)><\\>
<ExpRef()> <Arg(node.left)> <BinaryLogicExpKindMap.(node.kind)> <Arg(node.right)>;
>>

BoolLiteralExpKindMap ::= [
    "TRUE": "true",
    "FALSE": "false"
]
BoolLiteralExp(node) ::= "<BoolLiteralExpKindMap.(node.kind)>"

CallExp(node) ::= <<
<node.arguments:Render()><\\>
<ExpRef()> <node.functionName>(<node.arguments:Arg(); separator=", ">);
<if(node.canRaiseEvent)>if(retcode == Constants.RAISED_EVENT) { return<if(function.retType)> <typeDefaultValue(function.retType)><endif>; }<endif>
>>

CastExp(node) ::= <<
<Render(node.expression)><\\>
<ExpRef()> <cast(node.castToType, Arg(node.expression))>;
>>

ComparisonExpKindMap ::= [
    "LT": "<",
    "LE": "<=",
    "GT": ">",
    "GE": ">=",
    "NE": "!=",
    "EQ": "=="
]
ComparisonExp(node) ::= <<
<Render(node.left)><\\>
<Render(node.right)><\\>
<ExpRef()> <Arg(node.left)> <ComparisonExpKindMap.(node.kind)> <Arg(node.right)>;
>>

DefaultExp(node) ::= <<
<ExpRef()> <typeDefaultValue(node.typeForDefault)>;
>>

GetAttributeExp(node) ::= <<
<Render(node.targetExpression)><\\>
<ExpRef()> <Arg(node.targetExpression)>.v<node.index>;
>>

GetAttributeExpLValue(node) ::= <<
<LValue(node.targetExpression)>.v<node.index>
>>

GetIndexExp(node) ::= <<
<Render(node.targetExpression)><\\>
<ExpRef()> <Arg(node.targetExpression)>.v<node.index>;
>>

GetIndexExpLValue(node) ::= <<
<LValue(node.targetExpression)>.v<node.index>
>>

GetItemExp(node) ::= <<
<Render(node.targetExpression)><\\>
<Render(node.indexerExpression)><\\>
<ExpRef()> <Arg(node.targetExpression)>.get(<Arg(node.indexerExpression)>);
>>

GroupExp(node) ::= <<
<Render(node.expression)>
>>

HaltExp(node) ::= <<
<ExpRef()> EVENT_HALT;
>>

IdExp(node) ::= <<
<ExpRef()> <node.name>;
>>

IdExpLValue(node) ::= "<node.name>"

InExp(node) ::= <<
<Render(node.right)><\\>
<Render(node.left)><\\>
<ExpRef()> <Arg(node.right)>.containsKey(<Arg(node.left)>);
>>

IntExp(node) ::= <<
<ExpRef()> <node.value>;
>>

KeysExp(node) ::= <<
<Render(node.expression)><\\>
<ExpRef()> <Args(node.expression)>.keys();
>>

MinusExp(node) ::= <<
<Render(node.expression)><\\>
<ExpRef()> -<Arg(node.expression)>;
>>

NamedTupleExp(node) ::= <<
<TupleExp(node)>
>>

NewExp(node) ::= <<
<Render(node.payloadExpression)><\\>
<ExpRef()> create\<<prefixMachineName(node.machineIdentifier)>\>(<Arg(node.payloadExpression)>);
>>

NondetExp(node) ::= <<
<ExpRef()> randomBool();
>>

NotExp(node) ::= <<
<Render(node.expression)><\\>
<ExpRef()> !<Arg(node.expression)>;
>>

NullExp(node) ::= <<
<ExpRef()> NULL;
>>

SizeofExp(node) ::= <<
<Render(node.expression)><\\>
<ExpRef()> <Arg(node.expression)>.size();
>>

ThisExp(node) ::= <<
<ExpRef()> this;
>>

TupleExp(node) ::= <<
<node.arguments:Render()><\\>
<ExpRef()> <type(node.expressionType)>(<node.arguments:Arg(); separator=", ">);
>>

ValueExp(node) ::= <<
<Render(node.expression)><\\>
<ExpRef()> <Arg(node.expression)>.values();
>>