import "common.stg"

PrefixEntryFunctionName(stateName) ::= "<stateName>Entry"
EntryFunctionName(state) ::= "<PrefixEntryFunctionName(state.name)>"

InvokeAuxFunction(function) ::= <<
<if(function.name)><function.name>(<if(function.params)>cast(<first(function.params.values)>, payload)<endif>);<endif>
>>

EntryFunction(state) ::= <<
inline void <EntryFunctionName(state)>(const PAny& payload) {
    states.set(states.size(), <state.name>);
    <InvokeAuxFunction(state.entryFunction)>
}
>>

TransitionFunctionWrapperName(function) ::= "<function.name>_Wrap"

TransitionFunction(function) ::= <<
inline void <TransitionFunctionWrapperName(function)>(const PAny& payload) {
    <InvokeAuxFunction(function)>
}
>>

MachineImplementationFile(projectName, program, machine) ::= <<
namespace <projectName> {

class <machineName(machine)> final : public PMachine {
    friend class Scheduler;
public:
    <machineName(machine)>(ExecutionEngine& engine):PMachine(engine) { }

    inline void start(const PAny& payload) override {
        <EntryFunctionName(machine.startState)>(payload);
    }

private:
    <rest(machine.stateDecls):{state | static const int <state.name> = <i>;}; separator="\n">

    /* region Entry Methods */
    <rest(machine.stateDecls):EntryFunction(); separator="\n\n">
    /* end Entry Methods */

    /* region Transition Methods */
    <machine.uniqueTransitions:TransitionFunction(); separator="\n\n">
    /* end Transition Methods */

    /* region Function Implementations */
    <machine.funDecls.values:FunctionImplementation(); separator="\n\n">
    /* end Function Implementations */

    /* region Machine Fields */
    <machine.varDecls.keys:{varName | <type(machine.varDecls.(varName))> <varName> = <typeDefaultValue(machine.varDecls.(varName))>;}; separator="\n">
    /* end Machine Fields  */

    /* region Jump Tables */
    inline bool isDefered(int state, int event) const override {
        static const bool _isDefered[][] = {<program.eventDecls:
                                        {e | {<machine.stateDecls:
                                            {state | <if(state.deferedEvents.(e.name))>true<else>false<endif>}; separator=",">\}};
                                    separator=",">};
        return _isDefered[state][event];
    }

    inline bool isGotoTransition(int state, int event) const override {
        static const bool _isGotoTransition[][] = {<program.eventDecls:
                                                {e | {<machine.stateDecls:
                                                    {state | <if(state.deferedEvents.(e.name))>true<else>false<endif>}; separator=",">\}};
                                            separator=",">};
        return _isGotoTransition[state][event];
    }

    inline ExitFunction getExitFunction(int state) const override {
        static ExitFunction _exitFunctions[] = {<machine.stateDecls: {state | &<if(state.exitFunction.isPresent)><state.exitFunction.get><else>exitIgnore<endif>}; separator=",">};
        return _exitFunctions[state];
    }

    inline TransitionFunction getTransition(int state, int event) const override {
        static TransitionFunction _transitions[][] = {<program.eventDecls:
                                                {e | {<machine.stateDecls:
                                                    {state | <if(state.transitionsMap.(e))>&<if(state.transitionsMap.(e).isPush)>transitionPushState<elseif(state.transitionsMap.(e).functionName)><state.transitionsMap.(e).functionName><else>emptyTransition<endif><else>NULL<endif>}; separator=",">\}};
                                            separator=",">};
        return _transitions[state][event];
    }

    inline EntryFunction getTransitionEntry(int state, int event) const override {
        static TransitionFunction _entries[][] = {<program.eventDecls:
                                                {e | {<machine.stateDecls:
                                                    {state | <if(state.transitionsMap.(e))>&<if(state.transitionsMap.(e).toStateName)><PrefixEntryFunctionName(state.transitionsMap.(e).toStateName)><else>emptyEntry<endif><else>NULL<endif>}; separator=",">\}};
                                            separator=",">};
        return _entries[state][event];
    }
    /* end Jump Tables */
}
>>
