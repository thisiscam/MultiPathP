import "common.stg"

PrefixEntryFunctionName(stateName) ::= "<stateName>Entry"
EntryFunctionName(state) ::= "<PrefixEntryFunctionName(state.name)>"

InvokeAuxFunction(function) ::= <<
<if(function.name)>self-><function.name>(<if(function.params)>payload<endif>);<endif>
>>

EntryFunction(state) ::= <<
static inline void <EntryFunctionName(state)>(<machineName(machine)>* self, const PAny& payload) {
    self->states.setTop(<state.name>);
    <InvokeAuxFunction(state.entryFunction)>
}
>>

TransitionFunctionWrapperSuffix(functionName) ::= "<functionName>_Wrap"
TransitionFunctionWrapperName(function) ::= "<TransitionFunctionWrapperSuffix(function.name)>"

TransitionFunction(function) ::= <<
static inline void <TransitionFunctionWrapperName(function)>(<machineName(machine)>* self, const PAny& payload) {
    <InvokeAuxFunction(function)>
}
>>

JumpTableRow(e) ::= <<
<if(state.transitionsMap.(e))>E(<(functionNameTemplate)()>)<else>NULL<endif>
>>

JumpTableRows(state) ::= <<
{<program.eventDecls:JumpTableRow(); separator=",">}
>>

JumpTable(functionNameTemplate) ::= <<
{
    <machine.stateDecls:JumpTableRows(); separator=",\n">
}
>>

TransitionJumpTableInner() ::= <<
<if(state.transitionsMap.(e).push)>pushTransition<elseif(state.transitionsMap.(e).functionName)><TransitionFunctionWrapperSuffix(state.transitionsMap.(e).functionName)><else>emptyTransition<endif>
>>

EntryJumpTableInner() ::= <<
<if(state.transitionsMap.(e).toStateName)><PrefixEntryFunctionName(state.transitionsMap.(e).toStateName)><else>emptyEntry<endif>
>>

MachineImplementationFile(projectName, program, machine) ::= <<
namespace <projectName> {

class <machineName(machine)> final : public PMachine {
    friend class Scheduler;
public:
    <machineName(machine)>(ExecutionEngine& engine):PMachine(engine) { }

    inline void start(const PAny& payload) override {
        <EntryFunctionName(machine.startState)>(this, payload);
    }

private:
    <rest(machine.stateDecls):{state | DECL_STATE(<state.name>);}; separator=",\n">

    /* region Entry Methods */
    <rest(machine.stateDecls):EntryFunction(); separator="\n\n">
    /* end Entry Methods */

    /* region Transition Methods */
    <machine.uniqueTransitions:TransitionFunction(); separator="\n\n">
    /* end Transition Methods */

    /* region Function Implementations */
    <machine.funDecls.values:FunctionImplementation(); separator="\n\n">
    /* end Function Implementations */

    /* region Machine Fields */
    <machine.varDecls.keys:{varName | <type(machine.varDecls.(varName))> <varName>;}; separator="\n">
    /* end Machine Fields  */

    /* region Jump Tables */
    inline IsDeferedMapType isDeferedMap() const override {
        static const IsDeferedMapType _isDefered = 
            {
                <machine.stateDecls: {state | <program.eventDecls: {e | <if(state.deferedEvents.(e.name))>{<state.name>, <e.name>\}<endif>}>}>
            };
        return _isDefered;
    }

    inline isGotoTransitionType isGotoTransitionMap() const override {
        static const bool _isGotoTransition[<length(machine.stateDecls)>][<length(program.eventDecls)>] =
            {
                <machine.stateDecls:
                {state | {<program.eventDecls:
                    {e | <if(state.transitionsMap.(e).toStateName)> true<else>false<endif>}; separator=",">\} /* <state.name> */};
                    separator=",\n">
            };
        return _isGotoTransition;
    }

    inline GetExitFunctionMapType getExitFunctionMap() const override {
        #define E(f) ((ExitFunction)&<machineName(machine)>::f)
        static ExitFunction _exitFunctions[] = {<machine.stateDecls: {state | &<machineName(machine)>::<if(state.exitFunction)>E(<state.exitFunction>)<else>emptyExit<endif>}; separator=",">};
        #undef E
        return _exitFunctions;
    }

    inline GetTransitionMapType getTransitionMap() const override {
        #define E(f) ((TransitionFunction)&<machineName(machine)>::f)
        static TransitionFunction _transitions[<length(machine.stateDecls)>][<length(program.eventDecls)>] = 
            <JumpTable("TransitionJumpTableInner")>;
        #undef E
        return _transitions;
    }

    inline GetTransitionEntryMapType getTransitionEntryMap() const override {
        #define E(f) ((TransitionFunction)&<machineName(machine)>::f)
        static TransitionFunction _entries[<length(machine.stateDecls)>][<length(program.eventDecls)>] = 
            <JumpTable("EntryJumpTableInner")>;
        #undef E
        return _entries;
    }
    /* end Jump Tables */
};

};
>>
